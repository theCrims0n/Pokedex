{"ast":null,"code":"import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\nconst renderPath = (ctx, node) => {\n  var _node$props;\n  const d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;\n  if (d) ctx.path(node.props.d);\n};\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;\n  const x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n  const y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n  const rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;\n  const ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;\n  const width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;\n  const height = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\nconst renderGroup = () => {\n  // noop\n};\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = function (ctx, cx, cy, rx, ry) {\n  if (cx === void 0) {\n    cx = 0;\n  }\n  if (cy === void 0) {\n    cy = 0;\n  }\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, cx, cy, rx, ry);\n};\nconst renderCircle = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3;\n  const cx = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;\n  const cy = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;\n  const r = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;\n  drawEllipse(ctx, cx, cy, r, r);\n};\nconst renderGlyphs = function (ctx, glyphs, positions, x, y, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm;\n\n  // Glyph encoding and positioning\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return ctx._glyphs(encodedGlyphs, encodedPositions, x, y, options);\n};\nconst renderRun$1 = (ctx, run) => {\n  const runAdvanceWidth = run.xAdvance;\n  const {\n    font,\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;\n  ctx.save();\n  const x = ((_line$box = line.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;\n  const y = ((_line$box2 = line.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;\n  const font = (_line$runs$ = line.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;\n  const scale = ((_line$runs$2 = line.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;\n  const width = line.xAdvance;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n  node.children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\n/**\n * Create pairs from array\n *\n * @template T\n * @param {T[]} values array\n * @returns {T[][]} pairs\n */\nconst pairs = values => {\n  const result = [];\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n\n/**\n * Parse svg-like points into number arrays\n *\n * @param {string} points string ex. \"20,30 50,60\"\n * @returns {number[][]} points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\nconst renderPolygon = (ctx, node) => {\n  renderPolyline(ctx, node);\n  ctx.closePath();\n};\nconst renderImage$1 = (ctx, node) => {\n  if (!node.image.data) return;\n  const {\n    x,\n    y\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style;\n\n  // Border top\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n\n  // Border right\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n\n  // Border bottom\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n\n  // Border left\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        const [xAngle, yAngle] = value;\n        ctx.skew(xAngle, yAngle, {\n          origin\n        });\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n    default:\n      {\n        console.error(`Transform operation: '${operation}' doesn't supported`);\n      }\n  }\n};\nconst applyTransformations = (ctx, node) => {\n  var _node$style, _node$props;\n  if (!node.origin) return;\n  const origin = [node.origin.left, node.origin.top];\n  const operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  var _node$props;\n  const path = normalizePath(absPath(parsePath(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nconst getCircleBoundingBox = node => {\n  var _node$props2, _node$props3, _node$props4;\n  const r = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;\n  const cx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;\n  const cy = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = node => {\n  var _node$props5, _node$props6, _node$props7, _node$props8;\n  const cx = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;\n  const cy = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;\n  const rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;\n  const ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = node => {\n  var _node$props9, _node$props10, _node$props11, _node$props12;\n  const x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;\n  const y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;\n  const x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;\n  const y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nconst getRectBoundingBox = node => {\n  var _node$props13, _node$props14, _node$props15, _node$props16;\n  const x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;\n  const y = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;\n  const width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;\n  const height = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;\n  return [x, y, x + width, y + height];\n};\nconst max = values => Math.max(-Infinity, ...values);\nconst min = values => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = node => {\n  var _node$props17;\n  const points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\nconst setStrokeWidth = (ctx, node) => {\n  var _node$props;\n  const lineWidth = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n  var _node$props2;\n  const strokeColor = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n  var _node$props3;\n  const opacity = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n  var _node$props4;\n  const fillOpacity = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n  var _node$props5;\n  const strokeOpacity = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n  var _node$props6;\n  const lineJoin = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n  var _node$props7;\n  const lineCap = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n  var _node$props8;\n  const value = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;\n  if (value) ctx.dash(value.split(',').map(Number));\n};\nconst hasLinearGradientFill = node => {\n  var _node$props9, _node$props9$fill;\n  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === P.LinearGradient;\n};\nconst hasRadialGradientFill = node => {\n  var _node$props10, _node$props10$fill;\n  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === P.RadialGradient;\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n  var _node$props11;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;\n  const x1 = gradient.props.x1 || 0;\n  const y1 = gradient.props.y1 || 0;\n  const x2 = gradient.props.x2 || 1;\n  const y2 = gradient.props.y2 || 0;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gx1 = m0 * x1 + m4;\n  const gy1 = m3 * y1 + m5;\n  const gx2 = m0 * x2 + m4;\n  const gy2 = m3 * y2 + m5;\n  const grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n  var _node$props12;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;\n  const cx = gradient.props.cx || 0.5;\n  const cy = gradient.props.cy || 0.5;\n  const fx = gradient.props.fx || cx;\n  const fy = gradient.props.fy || cy;\n  const r = gradient.props.r || 0.5;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gr = r * m0;\n  const gcx = m0 * cx + m4;\n  const gcy = m3 * cy + m5;\n  const gfx = m0 * fx + m4;\n  const gfy = m3 * fy + m5;\n  const grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n  var _node$props13;\n  const fillColor = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n  if (props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if (props.fill) {\n    ctx.fill(props.fillRule);\n  } else if (props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nconst noop = () => {};\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(`SVG node of type ${node.type} is not currently supported`);\n  }\n};\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n  var _node$props14;\n  const value = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nconst resolveAspectRatio = (ctx, node) => {\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio = {}\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio;\n  if (viewBox == null || width == null || height == null) return;\n  const x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;\n  const y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;\n  const logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;\n  const logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nconst moveToOrigin = (ctx, node) => {\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\nconst black = {\n  value: [0, 0, 0],\n  opacity: 1\n};\nconst parseColor = hex => {\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\n\n/* eslint-disable no-param-reassign */\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nconst renderAttachments = (ctx, run) => {\n  ctx.save();\n  const {\n    font\n  } = run.attributes;\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nconst renderRun = (ctx, run, options) => {\n  const {\n    font,\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height,\n    descent,\n    xAdvance\n  } = run;\n  if (options.outlineRuns) {\n    ctx.rect(0, -height, xAdvance, height).stroke();\n  }\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nconst renderDecorationLine = (ctx, line) => {\n  ctx.save();\n  ctx.lineWidth(line.rect.height);\n  ctx.strokeOpacity(line.opacity);\n  if (/dashed/.test(line.style)) {\n    ctx.dash(3 * line.rect.height);\n  } else if (/dotted/.test(line.style)) {\n    ctx.dash(line.rect.height);\n  }\n  if (/wavy/.test(line.style)) {\n    const dist = Math.max(2, line.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(line.rect.width / (2 * step));\n\n    // Adjust step to fill entire width\n    const remainingWidth = line.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = line.rect.y + dist;\n    const cp2y = line.rect.y - dist;\n    let {\n      x\n    } = line.rect;\n    ctx.moveTo(line.rect.x, line.rect.y);\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(line.rect.x, line.rect.y);\n    ctx.lineTo(line.rect.x + line.rect.width, line.rect.y);\n    if (/double/.test(line.style)) {\n      ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);\n      ctx.lineTo(line.rect.x + line.rect.width, line.rect.y + line.rect.height * 2);\n    }\n  }\n  ctx.stroke(line.color);\n  ctx.restore();\n};\nconst renderLine = (ctx, line, options) => {\n  const lineAscent = line.ascent;\n  if (options.outlineLines) {\n    ctx.rect(line.box.x, line.box.y, line.box.width, line.box.height).stroke();\n  }\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      const overflowRight = isLastRun ? line.overflowRight : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: run.xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run, options);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  for (let i = 0; i < line.decorationLines.length; i += 1) {\n    const decorationLine = line.decorationLines[i];\n    renderDecorationLine(ctx, decorationLine);\n  }\n  ctx.restore();\n};\nconst renderBlock = (ctx, block, options) => {\n  block.forEach(line => {\n    renderLine(ctx, line, options);\n  });\n};\nconst renderText = (ctx, node) => {\n  var _node$box, _node$box2;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.paddingTop) || 0;\n  const paddingLeft = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingLeft) || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block, {});\n  });\n  ctx.restore();\n};\nconst renderPage = (ctx, node) => {\n  var _node$props;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\nconst renderNote = (ctx, node) => {\n  var _node$children, _node$style, _node$style2;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || '';\n  const color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;\n  const borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;\n  ctx.note(left, top, 0, 0, value, {\n    color,\n    borderWidth\n  });\n};\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\nconst resolveObjectFit = function (type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\nconst drawImage = function (ctx, node, options) {\n  var _node$style, _node$style2, _node$style3, _node$style4;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;\n  const objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;\n  const objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;\n  const objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || ctx.embedImage(node.image.data);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(`Image with src '${JSON.stringify(node.props.src)}' skipped due to invalid dimensions`);\n    }\n  }\n};\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nconst debugPadding = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nconst getMargin = box => {\n  const marginLeft = box.marginLeft === 'auto' ? 0 : box.marginLeft;\n  const marginTop = box.marginTop === 'auto' ? 0 : box.marginTop;\n  const marginRight = box.marginRight === 'auto' ? 0 : box.marginRight;\n  const marginBottom = box.marginBottom === 'auto' ? 0 : box.marginBottom;\n  return {\n    marginLeft,\n    marginTop,\n    marginRight,\n    marginBottom\n  };\n};\nconst debugMargin = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1));\n};\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nconst renderDebug = (ctx, node) => {\n  var _node$props;\n  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug)) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => ({\n    ...acc,\n    [prop]: function () {\n      ctx[prop](...arguments);\n      return p;\n    }\n  }), {});\n  return p;\n};\nconst renderCanvas = (ctx, node) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = node.box;\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\nconst drawBackground = (ctx, node) => {\n  var _node$style;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nconst renderBackground = (ctx, node) => {\n  var _node$style2;\n  const hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\nconst isSrcId = value => /^#.+/.test(value);\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const src = props.src || props.href;\n  if (src) {\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    ctx[method](left, top, width, height, value);\n  }\n};\nconst setDestination = (ctx, node) => {\n  var _node$props;\n  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  const children = node.children || [];\n  const renderChild = child => renderNode(ctx, child, options);\n  children.forEach(renderChild);\n  ctx.restore();\n};\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst renderNode = (ctx, node, options) => {\n  var _node$style;\n  const overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\n\n/* eslint-disable no-param-reassign */\n\nconst setPDFMetadata = target => (key, value) => {\n  if (value) target.info[key] = value;\n};\n\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} doc document root\n */\nconst addMetadata = (ctx, doc) => {\n  const setProp = setPDFMetadata(ctx);\n  const props = doc.props || {};\n  const title = props.title || null;\n  const author = props.author || null;\n  const subject = props.subject || null;\n  const keywords = props.keywords || null;\n  const creator = props.creator ?? 'react-pdf';\n  const producer = props.producer ?? 'react-pdf';\n  const creationDate = props.creationDate || new Date();\n  const modificationDate = props.modificationDate || null;\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n  setProp('CreationDate', creationDate);\n  setProp('ModificationDate', modificationDate);\n};\n\n/* eslint-disable no-param-reassign */\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  var _node$props;\n  const bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;\n  if (bookmark) {\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map()\n  };\n  addMetadata(ctx, doc);\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\nexport { render as default };","map":{"version":3,"names":["P","isNil","matchPercent","absPath","parsePath","normalizePath","colorString","renderPath","ctx","node","_node$props","d","props","path","KAPPA$3","Math","sqrt","renderRect","_node$props2","_node$props3","_node$props4","_node$props5","_node$props6","x","y","rx","ry","width","height","krx","kry","moveTo","lineTo","bezierCurveTo","closePath","renderLine$1","x1","x2","y1","y2","renderGroup","KAPPA$2","drawEllipse","cx","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","r","renderGlyphs","glyphs","positions","options","scale","_fontSize","unitsPerEm","_font","font","advanceWidthScale","encodedGlyphs","encodeGlyphs","encodedPositions","map","pos","i","xAdvance","yAdvance","xOffset","yOffset","advanceWidth","_glyphs","renderRun$1","run","runAdvanceWidth","fontSize","color","opacity","attributes","fillColor","fillOpacity","sbix","COLR","CPAL","save","translate","ascent","length","position","glyph","render","restore","name","error","console","log","renderSpan","line","textAnchor","dominantBaseline","_line$box","_line$box2","_line$runs$","_line$runs$2","_line$runs$2$attribut","box","runs","xHeight","descent","capHeight","xTranslate","yTranslate","forEach","renderSvgText","children","span","lines","pairs","values","result","push","parsePoints","points","trim","replace","split","slice","mappedValues","parseFloat","drawPolyline","p","renderPolyline","renderPolygon","renderImage$1","image","data","style","paddingTop","paddingLeft","warn","href","KAPPA$1","clipNode","top","left","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","rbr","cbr","rbl","cbl","rtl","ctl","clip","applySingleTransformation","transform","origin","operation","value","scaleX","scaleY","angle","rotate","xAngle","yAngle","skew","applyTransformations","_node$style","operations","getPathBoundingBox","bounds","Infinity","l","j","getCircleBoundingBox","getEllipseBoundingBox","_node$props7","_node$props8","getLineBoundingBox","_node$props9","_node$props10","_node$props11","_node$props12","max","getRectBoundingBox","_node$props13","_node$props14","_node$props15","_node$props16","getPolylineBoundingBox","_node$props17","xValues","yValues","boundingBoxFns","Rect","Line","Path","Circle","Ellipse","Polygon","Polyline","getBoundingBox","boundingBoxFn","type","setStrokeWidth","lineWidth","strokeWidth","setStrokeColor","strokeColor","stroke","setOpacity","setFillOpacity","setStrokeOpacity","strokeOpacity","setLineJoin","lineJoin","strokeLinejoin","setLineCap","lineCap","strokeLinecap","setLineDash","strokeDasharray","dash","Number","hasLinearGradientFill","_node$props9$fill","fill","LinearGradient","hasRadialGradientFill","_node$props10$fill","RadialGradient","setLinearGradientFill","bbox","gradient","m0","m3","m4","m5","gx1","gy1","gx2","gy2","grad","linearGradient","stop","offset","stopColor","stopOpacity","setRadialGradientFill","fx","fy","gr","gcx","gcy","gfx","gfy","radialGradient","setFillColor","setFill","draw","fillAndStroke","fillRule","noop","renderFns$1","Tspan","TextInstance","G","Text","Image","renderNode$1","renderFn","drawNode","clipPath","child","drawChildren","resolveAspectRatio","viewBox","preserveAspectRatio","meetOrSlice","align","minX","minY","logicalWidth","maxX","logicalHeight","maxY","logicalRatio","physicalRatio","moveToOrigin","renderSvg","black","parseColor","hex","parsed","get","to","DEST_REGEXP","isSrcId$1","src","match","renderAttachment","attachment","fit","valign","renderAttachments","space","glyphForCodePoint","objectReplacement","attachmentAdvance","id","renderRun","link","outlineRuns","rect","goTo","renderBackground$1","backgroundColor","renderDecorationLine","test","dist","step","stepCount","floor","remainingWidth","adjustment","cp1y","cp2y","renderLine","lineAscent","outlineLines","isLastRun","overflowRight","backgroundRect","decorationLines","decorationLine","renderBlock","block","renderText","_node$box","_node$box2","blocks","initialY","offsetX","alignOffset","renderPage","dpi","userUnit","addPage","size","margin","renderNote","_node$children","_node$style2","borderWidth","note","isNumeric","n","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","px","py","cr","ir","pxp","pyp","pxv","percent","pyv","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","drawImage","_node$style3","_node$style4","objectFit","objectPositionX","objectPositionY","paddingRight","paddingBottom","imageCache","Map","cacheKey","key","embedImage","set","imageOpacity","JSON","stringify","renderImage","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","getMargin","marginLeft","marginTop","marginRight","marginBottom","debugMargin","debugText","roundedWidth","round","roundedHeight","text","debugOrigin","circle","renderDebug","debug","availableMethods","painter","reduce","acc","prop","arguments","renderCanvas","availableWidth","availableHeight","paint","KAPPA","clipBorderTop","layout","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","drawBackground","nodeOpacity","renderBackground","hasBackground","isSrcId","setLink","isId","method","setDestination","addNamedDestination","isRecursiveNode","Svg","renderChildren","renderChild","renderNode","renderFns","Note","Canvas","Link","overflowHidden","overflow","shouldRenderChildren","Page","setPDFMetadata","target","info","addMetadata","doc","setProp","title","author","subject","keywords","creator","producer","creationDate","Date","modificationDate","addNodeBookmark","pageNumber","registry","bookmark","parent","expanded","zoom","outline","instance","addItem","ref","addBookmarks","root","pages","page","end","default"],"sources":["C:/Users/broad/OneDrive/Documentos/FULLSTACK-TEST/pokedex/client/node_modules/@react-pdf/render/lib/index.js"],"sourcesContent":["import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\n\nconst renderPath = (ctx, node) => {\n  var _node$props;\n  const d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;\n  if (d) ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;\n  const x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n  const y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n  const rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;\n  const ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;\n  const width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;\n  const height = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {\n  // noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = function (ctx, cx, cy, rx, ry) {\n  if (cx === void 0) {\n    cx = 0;\n  }\n  if (cy === void 0) {\n    cy = 0;\n  }\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, cx, cy, rx, ry);\n};\n\nconst renderCircle = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3;\n  const cx = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;\n  const cy = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;\n  const r = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;\n  drawEllipse(ctx, cx, cy, r, r);\n};\n\nconst renderGlyphs = function (ctx, glyphs, positions, x, y, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm;\n\n  // Glyph encoding and positioning\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return ctx._glyphs(encodedGlyphs, encodedPositions, x, y, options);\n};\n\nconst renderRun$1 = (ctx, run) => {\n  const runAdvanceWidth = run.xAdvance;\n  const {\n    font,\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;\n  ctx.save();\n  const x = ((_line$box = line.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;\n  const y = ((_line$box2 = line.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;\n  const font = (_line$runs$ = line.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;\n  const scale = ((_line$runs$2 = line.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;\n  const width = line.xAdvance;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n  node.children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\n/**\n * Create pairs from array\n *\n * @template T\n * @param {T[]} values array\n * @returns {T[][]} pairs\n */\nconst pairs = values => {\n  const result = [];\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n\n/**\n * Parse svg-like points into number arrays\n *\n * @param {string} points string ex. \"20,30 50,60\"\n * @returns {number[][]} points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n  renderPolyline(ctx, node);\n  ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n  if (!node.image.data) return;\n  const {\n    x,\n    y\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style;\n\n  // Border top\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n\n  // Border right\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n\n  // Border bottom\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n\n  // Border left\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        const [xAngle, yAngle] = value;\n        ctx.skew(xAngle, yAngle, {\n          origin\n        });\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n    default:\n      {\n        console.error(`Transform operation: '${operation}' doesn't supported`);\n      }\n  }\n};\nconst applyTransformations = (ctx, node) => {\n  var _node$style, _node$props;\n  if (!node.origin) return;\n  const origin = [node.origin.left, node.origin.top];\n  const operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  var _node$props;\n  const path = normalizePath(absPath(parsePath(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nconst getCircleBoundingBox = node => {\n  var _node$props2, _node$props3, _node$props4;\n  const r = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;\n  const cx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;\n  const cy = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = node => {\n  var _node$props5, _node$props6, _node$props7, _node$props8;\n  const cx = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;\n  const cy = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;\n  const rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;\n  const ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = node => {\n  var _node$props9, _node$props10, _node$props11, _node$props12;\n  const x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;\n  const y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;\n  const x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;\n  const y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nconst getRectBoundingBox = node => {\n  var _node$props13, _node$props14, _node$props15, _node$props16;\n  const x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;\n  const y = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;\n  const width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;\n  const height = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;\n  return [x, y, x + width, y + height];\n};\nconst max = values => Math.max(-Infinity, ...values);\nconst min = values => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = node => {\n  var _node$props17;\n  const points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n  var _node$props;\n  const lineWidth = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n  var _node$props2;\n  const strokeColor = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n  var _node$props3;\n  const opacity = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n  var _node$props4;\n  const fillOpacity = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n  var _node$props5;\n  const strokeOpacity = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n  var _node$props6;\n  const lineJoin = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n  var _node$props7;\n  const lineCap = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n  var _node$props8;\n  const value = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;\n  if (value) ctx.dash(value.split(',').map(Number));\n};\nconst hasLinearGradientFill = node => {\n  var _node$props9, _node$props9$fill;\n  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === P.LinearGradient;\n};\nconst hasRadialGradientFill = node => {\n  var _node$props10, _node$props10$fill;\n  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === P.RadialGradient;\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n  var _node$props11;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;\n  const x1 = gradient.props.x1 || 0;\n  const y1 = gradient.props.y1 || 0;\n  const x2 = gradient.props.x2 || 1;\n  const y2 = gradient.props.y2 || 0;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gx1 = m0 * x1 + m4;\n  const gy1 = m3 * y1 + m5;\n  const gx2 = m0 * x2 + m4;\n  const gy2 = m3 * y2 + m5;\n  const grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n  var _node$props12;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;\n  const cx = gradient.props.cx || 0.5;\n  const cy = gradient.props.cy || 0.5;\n  const fx = gradient.props.fx || cx;\n  const fy = gradient.props.fy || cy;\n  const r = gradient.props.r || 0.5;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gr = r * m0;\n  const gcx = m0 * cx + m4;\n  const gcy = m3 * cy + m5;\n  const gfx = m0 * fx + m4;\n  const gfy = m3 * fy + m5;\n  const grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n  var _node$props13;\n  const fillColor = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n  if (props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if (props.fill) {\n    ctx.fill(props.fillRule);\n  } else if (props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nconst noop = () => {};\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(`SVG node of type ${node.type} is not currently supported`);\n  }\n};\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n  var _node$props14;\n  const value = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nconst resolveAspectRatio = (ctx, node) => {\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio = {}\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio;\n  if (viewBox == null || width == null || height == null) return;\n  const x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;\n  const y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;\n  const logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;\n  const logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nconst moveToOrigin = (ctx, node) => {\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\n\nconst black = {\n  value: [0, 0, 0],\n  opacity: 1\n};\nconst parseColor = hex => {\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\n\n/* eslint-disable no-param-reassign */\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nconst renderAttachments = (ctx, run) => {\n  ctx.save();\n  const {\n    font\n  } = run.attributes;\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nconst renderRun = (ctx, run, options) => {\n  const {\n    font,\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height,\n    descent,\n    xAdvance\n  } = run;\n  if (options.outlineRuns) {\n    ctx.rect(0, -height, xAdvance, height).stroke();\n  }\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nconst renderDecorationLine = (ctx, line) => {\n  ctx.save();\n  ctx.lineWidth(line.rect.height);\n  ctx.strokeOpacity(line.opacity);\n  if (/dashed/.test(line.style)) {\n    ctx.dash(3 * line.rect.height);\n  } else if (/dotted/.test(line.style)) {\n    ctx.dash(line.rect.height);\n  }\n  if (/wavy/.test(line.style)) {\n    const dist = Math.max(2, line.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(line.rect.width / (2 * step));\n\n    // Adjust step to fill entire width\n    const remainingWidth = line.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = line.rect.y + dist;\n    const cp2y = line.rect.y - dist;\n    let {\n      x\n    } = line.rect;\n    ctx.moveTo(line.rect.x, line.rect.y);\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(line.rect.x, line.rect.y);\n    ctx.lineTo(line.rect.x + line.rect.width, line.rect.y);\n    if (/double/.test(line.style)) {\n      ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);\n      ctx.lineTo(line.rect.x + line.rect.width, line.rect.y + line.rect.height * 2);\n    }\n  }\n  ctx.stroke(line.color);\n  ctx.restore();\n};\nconst renderLine = (ctx, line, options) => {\n  const lineAscent = line.ascent;\n  if (options.outlineLines) {\n    ctx.rect(line.box.x, line.box.y, line.box.width, line.box.height).stroke();\n  }\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      const overflowRight = isLastRun ? line.overflowRight : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: run.xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run, options);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  for (let i = 0; i < line.decorationLines.length; i += 1) {\n    const decorationLine = line.decorationLines[i];\n    renderDecorationLine(ctx, decorationLine);\n  }\n  ctx.restore();\n};\nconst renderBlock = (ctx, block, options) => {\n  block.forEach(line => {\n    renderLine(ctx, line, options);\n  });\n};\nconst renderText = (ctx, node) => {\n  var _node$box, _node$box2;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.paddingTop) || 0;\n  const paddingLeft = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingLeft) || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block, {});\n  });\n  ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n  var _node$props;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\n\nconst renderNote = (ctx, node) => {\n  var _node$children, _node$style, _node$style2;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || '';\n  const color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;\n  const borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;\n  ctx.note(left, top, 0, 0, value, {\n    color,\n    borderWidth\n  });\n};\n\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\nconst resolveObjectFit = function (type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nconst drawImage = function (ctx, node, options) {\n  var _node$style, _node$style2, _node$style3, _node$style4;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;\n  const objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;\n  const objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;\n  const objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || ctx.embedImage(node.image.data);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(`Image with src '${JSON.stringify(node.props.src)}' skipped due to invalid dimensions`);\n    }\n  }\n};\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nconst debugPadding = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nconst getMargin = box => {\n  const marginLeft = box.marginLeft === 'auto' ? 0 : box.marginLeft;\n  const marginTop = box.marginTop === 'auto' ? 0 : box.marginTop;\n  const marginRight = box.marginRight === 'auto' ? 0 : box.marginRight;\n  const marginBottom = box.marginBottom === 'auto' ? 0 : box.marginBottom;\n  return {\n    marginLeft,\n    marginTop,\n    marginRight,\n    marginBottom\n  };\n};\nconst debugMargin = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1));\n};\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nconst renderDebug = (ctx, node) => {\n  var _node$props;\n  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug)) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\n\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => ({\n    ...acc,\n    [prop]: function () {\n      ctx[prop](...arguments);\n      return p;\n    }\n  }), {});\n  return p;\n};\nconst renderCanvas = (ctx, node) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = node.box;\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n  var _node$style;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nconst renderBackground = (ctx, node) => {\n  var _node$style2;\n  const hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\n\nconst isSrcId = value => /^#.+/.test(value);\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const src = props.src || props.href;\n  if (src) {\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    ctx[method](left, top, width, height, value);\n  }\n};\n\nconst setDestination = (ctx, node) => {\n  var _node$props;\n  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\n\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  const children = node.children || [];\n  const renderChild = child => renderNode(ctx, child, options);\n  children.forEach(renderChild);\n  ctx.restore();\n};\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst renderNode = (ctx, node, options) => {\n  var _node$style;\n  const overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\n\n/* eslint-disable no-param-reassign */\n\nconst setPDFMetadata = target => (key, value) => {\n  if (value) target.info[key] = value;\n};\n\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} doc document root\n */\nconst addMetadata = (ctx, doc) => {\n  const setProp = setPDFMetadata(ctx);\n  const props = doc.props || {};\n  const title = props.title || null;\n  const author = props.author || null;\n  const subject = props.subject || null;\n  const keywords = props.keywords || null;\n  const creator = props.creator ?? 'react-pdf';\n  const producer = props.producer ?? 'react-pdf';\n  const creationDate = props.creationDate || new Date();\n  const modificationDate = props.modificationDate || null;\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n  setProp('CreationDate', creationDate);\n  setProp('ModificationDate', modificationDate);\n};\n\n/* eslint-disable no-param-reassign */\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  var _node$props;\n  const bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;\n  if (bookmark) {\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\n\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map()\n  };\n  addMetadata(ctx, doc);\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\n\nexport { render as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}